// cfdg.y
// this file is part of Context Free
// ---------------------
// Copyright (C) 2005-2008 Mark Lentczner - markl@glyphic.com
// Copyright (C) 2005-2013 John Horigan - john@glyphic.com
// Copyright (C) 2005 Chris Coyne - ccoyne77@gmail.com
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
// 
// John Horigan can be contacted at john@glyphic.com or at
// John Horigan, 1209 Villa St., Mountain View, CA 94041-1123, USA
//
// Mark Lentczner can be contacted at markl@glyphic.com or at
// Mark Lentczner, 1209 Villa St., Mountain View, CA 94041-1123, USA
//
//


%skeleton "lalr1.cc"                          /*  -*- C++ -*- */
%require "2.3"
%defines
%define "parser_class_name" "CfdgParser"
%locations
%expect 3
//%debug
%parse-param {class Builder& driver}
%lex-param {class Builder& driver}

%{
#include "builder.h"
#include <string>
#include <list>
namespace AST {
    class ASTexpression;
    class ASTmodTerm;
    class ASTmodification;
    class ASTpath;
    class ASTreplacement;
    class ASTbodyContainer;
    class ASTloop;
    class ASTif;
    class ASTswitch;
    class ASTpathBody;
    class ASTpathLoop;
    class ASTruleSpecifier;
    class ASTrule;
    class ASTdefine;
}
%}

%union
{
    int modToken;
    std::string*  string;
    const std::string*  cstring;
    AST::ASTexpression* expression;
    AST::ASTmodTerm* term;
    AST::ASTmodification* mod;
    AST::ASTreplacement* component;
    AST::ASTloop* loopObj;
    AST::ASTif* ifObj;
    AST::ASTswitch* switchObj;
    AST::ASTruleSpecifier* ruleSpec;
    AST::ASTrule* ruleObj;
    AST::ASTrepContainer* bodyObj;
    AST::ASTdefine* defObj;
};

%{
#include "astreplacement.h"
#include "astexpression.h"
    
    using namespace AST;
%}

%token STARTSHAPE
%token CFDG2
%token CFDG3
%token SHAPE
%token RULE
%token PATH
%token DEFINE
%token BECOMES
%token LOOP
%token FINALLY
%token IF
%token ELSE
%token SWITCH
%token CASE
%token CLONE
%token LET
%token <modToken> MODTYPE
%token <modToken> PARAM
%token BACKGROUND
%token BADEOF     /* passed when EOF/EOL is unexpected */
%token GOODEOF    /* passed at end of include file */
%token RANGEOP
%token PLUSMINUSOP
%token <string> USER_STRING
%token <string> USER_INTEGER
%token <string> USER_RATIONAL
%token <string> USER_FILENAME
%token <string> USER_QSTRING
%token <string> USER_ARRAYNAME
%token INCLUDE
%token IMPORT
%token TILE
%token <term> PARAMETERS
%token <string> USER_PATHOP
%token <term> STROKEWIDTH
%token LE
%token LT
%token GE
%token GT
%token EQ
%token NEQ
%token NOT
%token AND
%token OR
%token XOR
%token CF_INFINITY
%right ','
%left XOR
%left OR
%left AND
%left EQ NEQ
%left LE LT GE GT
%left RANGEOP PLUSMINUSOP
%left '-' '+' '_'
%left '*' '/'
%left NOT NEG POS    /* negation--unary minus, unary identity */
%right '^'    /* exponentiation */
%type <expression> exp exp2 exp3 expfunc exp2func explist arglist parameter_spec letBody
%type <mod> modification modification_v2 buncha_adjustments
%type <term> adjustment
%type <component> element element_simple
%type <component> pathOp_v2 pathOp_simple_v2 replacement_v2 replacement_simple_v2
/* %type <definitions> buncha_definitions buncha_parameters parameter_list buncha_global_definitions */
%type <component> statement statement_v2 initialization initialization_v2 directive_v2 rule path shape_singleton transHeader rule_v2 path_v2
%type <loopObj> loopHeader element_loop loopHeader_v2
%type <ifObj> ifHeader ifElseHeader
%type <switchObj> switchHeader
%type <ruleObj> rule_header path_header rule_header_v2 path_header_v2 shape_singleton_header
%type <string> fileString fileNameSpace shapeName
%type <cstring> directive_string
%type <modToken> caseHeader
%type <bodyObj> letHeader
%type <defObj> definition_header global_definition_header function_definition_header global_definition definition

%destructor { delete $$; } USER_STRING USER_FILENAME USER_QSTRING USER_PATHOP USER_ARRAYNAME fileString fileNameSpace shapeName
%destructor { } directive_string
%destructor { delete $$; } definition_header global_definition_header function_definition_header global_definition definition
%destructor { delete $$; } exp exp2 exp3 expfunc exp2func explist arglist parameter_spec letBody
%destructor { delete $$; } adjustment
%destructor { delete $$; } modification modification_v2 buncha_adjustments
%destructor { driver.pop_repContainer(nullptr); delete $$; } loopHeader_v2
%destructor { driver.pop_repContainer(nullptr); delete $$; } element_loop loopHeader
%destructor { delete $$; } statement statement_v2 initialization initialization_v2 directive_v2 rule path element element_simple shape_singleton
%destructor { driver.pop_repContainer(nullptr); delete $$; } shape_singleton_header transHeader
%destructor { delete $$; } pathOp_v2 pathOp_simple_v2 replacement_v2 replacement_simple_v2
%destructor { driver.pop_repContainer(nullptr); delete $$; } rule_header path_header
%destructor { driver.pop_repContainer(nullptr); delete $$; } rule_header_v2 path_header_v2
%destructor { driver.pop_repContainer(nullptr); delete $$; } ifHeader ifElseHeader
%destructor { delete $$; } switchHeader
%destructor { driver.pop_repContainer(nullptr); } caseHeader
%destructor { driver.pop_repContainer(nullptr); delete $$; } letHeader
%{
#include "scanner.h"
#include "math.h"
#include "builder.h"
#include <cassert>

#undef yylex
#define yylex driver.lexer->lex
%}

%%

choose:
        CFDG2 cfdg2 | CFDG3 cfdg3;

cfdg2:
        cfdg2 statement_v2 {
            if ($2) {
                driver.push_rep($2, true);
            }
        }
        |
        ;

cfdg3:
        cfdg3 statement {
            if ($2) {
                driver.push_rep($2, true);
            }
        }
        |
        ;
        
statement:
          initialization
        | import { $$ = nullptr; }
        | eof { $$ = nullptr; }
        | rule
        | path
        | shape { $$ = nullptr; }
        | shape_singleton
        | global_definition { $$ = $1; }
        | v2stuff {
            error(@1, "Illegal mixture of old and new elements");
            $$ = nullptr;
        }
        ;
        
statement_v2:
        initialization_v2
        | directive_v2
        | inclusion { $$ = nullptr; }
        | eof { $$ = nullptr; }
        | rule_v2
        | path_v2
        | v3clues {
            if (driver.lexer->maybeVersion == token::CFDG2) {
                error(@1, "Illegal mixture of old and new elements");
            } else {
                driver.lexer->maybeVersion = token::CFDG3;
            }
            $$ = nullptr;
            YYABORT;
        }
        ;

v3clues:
        USER_STRING BECOMES { delete $1; }
        | MODTYPE BECOMES {}
        | PARAM BECOMES {}
        | USER_STRING '(' { delete $1; }
        | USER_STRING USER_STRING '(' { delete $1; delete $2; }
        | IMPORT
        | SHAPE
        | PATH USER_STRING '(' { delete $2; }
        | STARTSHAPE USER_STRING '(' { delete $2; }
        | STARTSHAPE USER_STRING '[' { delete $2; }
        | STARTSHAPE USER_ARRAYNAME '[' { delete $2; }
        ;

v2stuff:
        BACKGROUND modification_v2 { delete $2; }
        | TILE modification_v2 { delete $2; }
        | MODTYPE modification_v2 { delete $2; }
        | INCLUDE fileString { delete $2; }
        | rule_header_v2 { delete $1; }
        ;

inclusion:
        INCLUDE fileString {
            str_ptr file($2); $2 = nullptr;
            driver.lexer->maybeVersion = token::CFDG2;
            driver.SetShape(nullptr);
            driver.IncludeFile(*file);
        }
        ;

import:
        IMPORT fileNameSpace fileString {
            str_ptr file($3); $3 = nullptr;
            str_ptr nm($2); $2 = nullptr;
            driver.SetShape(nullptr);
            driver.IncludeFile(*file);
            if (nm)
                driver.PushNameSpace(std::move(nm), @2);
        }
        ;

eof:
        GOODEOF {
            if (driver.EndInclude())
                YYACCEPT;
        }
        ;

fileString:
        USER_FILENAME | USER_QSTRING;

fileNameSpace:
        '@' USER_STRING { $$ = $2; }
        | { $$ = nullptr; }
        ;

initialization:
        STARTSHAPE USER_STRING parameter_spec modification {
            str_ptr name($2); $2 = nullptr;
            exp_ptr p($3); $3 = nullptr;
            mod_ptr mod($4); $4 = nullptr;
            driver.SetShape(nullptr);
            ASTdefine* cfg = driver.MakeDefinition(CFDG::ParamNames[CFG::StartShape], @$, false);
            if (cfg)
                cfg->mExpression.reset(driver.MakeRuleSpec(*name, std::move(p), @2, std::move(mod), true));
            $$ = cfg;
        }
        |
        STARTSHAPE USER_ARRAYNAME modification {
            str_ptr name($2); $2 = nullptr;
            mod_ptr mod($3); $3 = nullptr;
            driver.SetShape(nullptr);
            ASTdefine* cfg = driver.MakeDefinition(CFDG::ParamNames[CFG::StartShape], @$, false);
            if (cfg)
                cfg->mExpression.reset(driver.MakeRuleSpec(*name, nullptr, @2, std::move(mod), true));
            $$ = cfg;
        }
        |
        STARTSHAPE USER_STRING parameter_spec {
            str_ptr name($2); $2 = nullptr;
            exp_ptr p($3); $3 = nullptr;
            driver.SetShape(nullptr);
            ASTdefine* cfg = driver.MakeDefinition(CFDG::ParamNames[CFG::StartShape], @$, false);
            if (cfg)
                cfg->mExpression.reset(driver.MakeRuleSpec(*name, std::move(p), @2, nullptr, true));
            $$ = cfg;
        }
        ;

initialization_v2:
        STARTSHAPE USER_STRING {
            str_ptr name($2); $2 = nullptr;
            driver.SetShape(nullptr);
            ASTdefine* cfg = driver.MakeDefinition(CFDG::ParamNames[CFG::StartShape], @$, false);
            if (cfg)
                cfg->mExpression.reset(driver.MakeRuleSpec(*name, nullptr, @2, nullptr, true));
            $$ = cfg;
        }
        ;

directive_v2:
        directive_string modification_v2 {
            exp_ptr mod($2); $2 = nullptr;
            ASTdefine* cfg = driver.MakeDefinition(*$1, @$, false);
            if (cfg)
                cfg->mExpression = std::move(mod);
            driver.lexer->maybeVersion = token::CFDG2;
            $$ = cfg;
        }
        ;

directive_string:
        BACKGROUND { $$ = &CFDG::ParamNames[CFG::Background]; }
        |
        TILE { $$ = &CFDG::ParamNames[CFG::Tile]; }
        |
        MODTYPE {
            switch ($1) {
            case ASTmodTerm::size:
                $$ = &CFDG::ParamNames[CFG::Size];
                break;
            case ASTmodTerm::time:
                $$ = &CFDG::ParamNames[CFG::Time];
                break;
            default:
                $$ = &CFDG::ParamNames[CFG::Size];
                error(@1, "Syntax error");
                break;
            }
        }
        ;

global_definition:
        global_definition_header exp2 {
            def_ptr var($1);  $1 = nullptr;
            exp_ptr exp($2);  $2 = nullptr;
            if (var) {
                if (var->isFunction) {
                    driver.pop_repContainer(nullptr);
                    driver.mParamDecls.mParameters.clear();
                    driver.mParamDecls.mStackCount = 0;
                }
                if (var->mConfigDepth >= 0 || var->isFunction) {
                    var->mExpression = std::move(exp);
                } else {
                    if (ASTmodification* mod = dynamic_cast<ASTmodification*>(exp.get()))
                        var->mChildChange.grab(mod);        // emptied ASTmod gets deleted
                    else
                        var->mExpression = std::move(exp);
                }
                $$ = var.release();
            } else {
                $$ = nullptr;
            }
        }
        ;

function_definition_header:
        SHAPE USER_STRING function_parameter_list BECOMES {
            str_ptr name($2); $2 = nullptr;
            ASTdefine* def = driver.MakeDefinition(*name, @$, true);
            if (def) {
                def->mType = RuleType;
                def->mTuplesize = 1;
            }
            $$ = def;
        }
        |
        USER_STRING function_parameter_list BECOMES {
            str_ptr name($1); $1 = nullptr;
            ASTdefine* def = driver.MakeDefinition(*name, @$, true);
            if (def) {
                def->mType = NumericType;
                def->mTuplesize = 1;
            }
            $$ = def;
        }
        |
        USER_STRING USER_STRING function_parameter_list BECOMES {
            str_ptr type($1); $1 = nullptr;
            str_ptr name($2); $2 = nullptr;
            ASTdefine* def = driver.MakeDefinition(*name, @$, true);
            if (def)
                def->mType = AST::decodeType(*type, def->mTuplesize, def->isNatural, @1);
            $$ = def;
        }
        |
        SHAPE MODTYPE function_parameter_list BECOMES {
            error(@2, "Reserved keyword: adjustment");
            $$ = nullptr;
        }
        |
        MODTYPE function_parameter_list BECOMES {
            error(@1, "Reserved keyword: adjustment");
            $$ = nullptr;
        }
        |
        USER_STRING MODTYPE function_parameter_list BECOMES {
            str_ptr type($1); $1 = nullptr;
            error(@2, "Reserved keyword: adjustment");
            $$ = nullptr;
        }
        ;

global_definition_header:
        function_definition_header {
            driver.push_repContainer(driver.mParamDecls);
            $$ = $1;
        }
        |
        definition_header {
            $$ = $1;
        }
        ;

definition_header:
        USER_STRING BECOMES {
            $$ = driver.MakeDefinition(*$1, @$, false);
        }
        | MODTYPE BECOMES {
            error(@1, "Reserved keyword: adjustment");
            $$ = nullptr;
        }
        ;

definition:
        definition_header exp2 {
            def_ptr var($1);  $1 = nullptr;
            exp_ptr exp($2);  $2 = nullptr;
            if (var) {
                if (ASTmodification* mod = dynamic_cast<ASTmodification*>(exp.get())) {
                    mod->modData.mRand64Seed.seed(0);
                    var->mChildChange.grab(mod);
                } else {
                    var->mExpression = std::move(exp);
                }
                $$ = var.release();
            } else {
                $$ = nullptr;
            }
        }
        ;

shape:
        SHAPE USER_STRING parameter_list {
            str_ptr name($2); $2 = nullptr;
            driver.SetShape(name.get(), @2);
        }
        ;

shape_singleton_header:
        shape '{' {
            driver.mInPathContainer = false;
            rule_ptr rule(new ASTrule(-1, @1));
            driver.AddRule(rule.get());
            driver.push_repContainer(rule->mRuleBody);
            $$ = rule.release();
        }

shape_singleton:
        shape_singleton_header buncha_elements '}' {
            $$ = $1;
            driver.pop_repContainer($1);
            driver.mInPathContainer = false;
        }
        ;

rule_header_v2:
        RULE USER_STRING {
            str_ptr name($2); $2 = nullptr;
            driver.SetShape(nullptr);
            rule_ptr rule(new ASTrule(driver.StringToShape(*name, @2, false), @$));
            driver.AddRule(rule.get());
            driver.push_repContainer(rule->mRuleBody);
            $$ = rule.release();
        }
        |
        RULE USER_STRING USER_RATIONAL {
            str_ptr name($2); $2 = nullptr;
            str_ptr weight($3); $3 = nullptr;
            driver.SetShape(nullptr);
            rule_ptr rule(new ASTrule(driver.StringToShape(*name, @2, false), 
                                      CFatof(weight->c_str()), 
                                      weight->find_first_of('%')  != std::string::npos,
                                      @$));
            driver.AddRule(rule.get());
            driver.push_repContainer(rule->mRuleBody);
            $$ = rule.release();
        }
        ;

rule_v2:
        rule_header_v2 '{' buncha_replacements_v2 '}' {
            driver.lexer->maybeVersion = token::CFDG2;
            $$ = $1;
            driver.pop_repContainer($1);
        }
        ;

rule_header:
        RULE {
            driver.mInPathContainer = false;
            rule_ptr rule(new ASTrule(-1, @1));
            driver.AddRule(rule.get());
            driver.push_repContainer(rule->mRuleBody);
            $$ = rule.release();
        }
        |
        RULE USER_RATIONAL {
            driver.mInPathContainer = false;
            str_ptr weight($2); $2 = nullptr;
            rule_ptr rule(new ASTrule(-1, CFatof(weight->c_str()),
                                      weight->find_first_of('%')  != std::string::npos,
                                      @$));
            driver.AddRule(rule.get());
            driver.push_repContainer(rule->mRuleBody);
            $$ = rule.release();
        }
        ;

path_header:
        PATH USER_STRING parameter_list {
            str_ptr name($2); $2 = nullptr;
            driver.SetShape(name.get(), @2, true);
            driver.mInPathContainer = true;
            rule_ptr newPath(new ASTrule(-1, @$));
            newPath->isPath = true;
            driver.AddRule(newPath.get());
            driver.push_repContainer(newPath->mRuleBody);
            $$ = newPath.release();
        }
        ;

rule:
        rule_header '{' buncha_elements '}' {
            $$ = $1;
            driver.pop_repContainer($1);
            driver.mInPathContainer = false;
        }
        ;

path:
        path_header '{' buncha_elements '}' {
            $$ = $1;
            driver.pop_repContainer($1);
            driver.mInPathContainer = false;
            driver.SetShape(nullptr);
        }
        ;

path_header_v2:
        PATH USER_STRING {
            str_ptr name($2); $2 = nullptr;
            driver.SetShape(nullptr);
            rule_ptr newPath(new ASTrule(driver.StringToShape(*name, @2, false), @$));
            newPath->isPath = true;
            driver.AddRule(newPath.get());
            driver.push_repContainer(newPath->mRuleBody);
            driver.mInPathContainer = true;
            $$ = newPath.release();
        }
        ;

path_v2:
        path_header_v2 '{' buncha_pathOps_v2 '}' {
            $$ = $1;
            driver.pop_repContainer($1);
        }
        ;

parameter:
        USER_STRING USER_STRING {
            str_ptr type($1); $1 = nullptr;
            str_ptr var($2); $2 = nullptr;
            driver.NextParameterDecl(*type, *var, @1, @2);
        }
        |
        SHAPE USER_STRING {
            static std::string shapeStr("shape");
            str_ptr var($2); $2 = nullptr;
            driver.NextParameterDecl(shapeStr, *var, @1, @2);
        }
        |
        USER_STRING MODTYPE {
            delete $1;
            error(@2, "Reserved keyword: adjustment");
        }
        |
        SHAPE MODTYPE {
            error(@2, "Reserved keyword: adjustment");
        }
        |
        USER_STRING {
            static const std::string numtype("number");
            str_ptr var($1); $1 = nullptr;
            driver.NextParameterDecl(numtype, *var, @1, @1);
        }
        |
        MODTYPE {
            error(@1, "Reserved keyword: adjustment");
        }
        ;

buncha_parameters:
        buncha_parameters ',' parameter
        | parameter
        ;

parameter_list:
        '(' buncha_parameters ')'
        |
        ;

function_parameter_list:
        '(' buncha_parameters ')'
        | '(' ')'
        ;

parameter_spec:
        '(' arglist ')' { $$ = $2;}
        | '(' BECOMES ')' { $$ = new ASTexpression(@$, false, false, AST::ReuseType); }
        | '(' ')' { $$ = nullptr; }
        | { $$ = nullptr; }
        ;

buncha_elements: 
        buncha_elements element {
            driver.push_rep($2);
        }
        |
        ;

buncha_pathOps_v2: 
        buncha_pathOps_v2 pathOp_v2 {
            driver.push_rep($2);
        }
        |
        ;

pathOp_simple_v2:
        USER_PATHOP '{' buncha_adjustments '}' {
            str_ptr pop($1); $1 = nullptr;
            mod_ptr mod($3); $3 = nullptr;
            driver.lexer->maybeVersion = token::CFDG2;
            $$ = new ASTpathOp(*pop, std::move(mod), @$);
        }
        |
        shapeName modification_v2 {
            str_ptr cmd($1); $1 = nullptr;
            mod_ptr mod($2); $2 = nullptr;
            driver.lexer->maybeVersion = token::CFDG2;
            rep_ptr item(new ASTpathCommand(*cmd, std::move(mod), nullptr, @$));
            $$ = item.release();
        }
        ;

element_simple:
        USER_PATHOP '(' exp2 ')' {
            str_ptr pop($1); $1 = nullptr;
            exp_ptr mod($3); $3 = nullptr;
            $$ = new ASTpathOp(*pop, std::move(mod), @$);
        }
        |
        USER_PATHOP '(' ')' {
            str_ptr pop($1); $1 = nullptr;
            exp_ptr mod;
            $$ = new ASTpathOp(*pop, std::move(mod), @$);
        }
        |
        shapeName parameter_spec modification {
            str_ptr cmd($1); $1 = nullptr;
            exp_ptr p($2); $2 = nullptr;
            mod_ptr mod($3); $3 = nullptr;
            rep_ptr item = driver.MakeElement(*cmd, std::move(mod),
                                              std::move(p), @$, false);
            $$ = item.release();
        }
        | 
        IF '(' exp2 ')' modification  { 
            exp_ptr args($3); $3 = nullptr;
            mod_ptr mod($5); $5 = nullptr;
            str_ptr func(new std::string("if"));
            args.reset(driver.MakeFunction(std::move(func), std::move(args), @1, @3, false));
            static const std::string ifstr("if");
            rep_ptr item = driver.MakeElement(ifstr, std::move(mod), std::move(args), @$, false);
            $$ = item.release();
        }
        |
        letHeader letBody modification {
            driver.pop_repContainer(nullptr);
            cont_ptr vars($1); $1 = nullptr;
            exp_ptr exp($2); $2 = nullptr;
            mod_ptr mod($3); $3 = nullptr;
            exp.reset(driver.MakeLet(@1, std::move(vars), std::move(exp)));      // must do unconditionally
            static const std::string letstr("let");
            rep_ptr item = driver.MakeElement(letstr, std::move(mod), std::move(exp), @$, false);
            $$ = item.release();
        }
        |
        PATH shapeName parameter_spec modification {
            str_ptr cmd($2); $2 = nullptr;
            exp_ptr p($3); $3 = nullptr;
            mod_ptr mod($4); $4 = nullptr;
            rep_ptr item = driver.MakeElement(*cmd, std::move(mod), std::move(p), @$, true);
            $$ = item.release();
        }
        ;

one_or_more_elements:
        '{' buncha_elements '}' { }
        |
        element {
            driver.push_rep($1);
        }
        ;

one_or_more_pathOp_v2:
        '{' buncha_pathOps_v2 '}' { }
        |
        pathOp_simple_v2 {
            driver.push_rep($1);
        }
        ;

caseBody:
        caseBody caseBody_element {
            driver.pop_repContainer(driver.switchStack.top());
        }
        |
        ;

caseBody_element:
        caseHeader one_or_more_elements
        ;

element:
        element_simple { 
            $$ = $1; 
        }
        |
        definition { 
            $$ = $1;
        }
        |
        element_loop { 
            $$ = $1;
            driver.pop_repContainer($1);
            if ($1->mRepType == 0) {
                delete $1;
                $$ = nullptr;
            }
        }
        |
        element_loop FINALLY {
            driver.pop_repContainer($1);
            driver.push_repContainer($1->mFinallyBody);
        } one_or_more_elements {
            driver.pop_repContainer($1);
            $$ = $1;
            if ($1->mRepType == 0) {
                delete $1;
                $$ = nullptr;
            }
        }
        |
        ifHeader one_or_more_elements {
            $$ = $1;
            driver.pop_repContainer($1);
            if ($1->mRepType == 0) {
                delete $1;
                $$ = nullptr;
            }
        }
        |
        ifElseHeader one_or_more_elements {
            $$ = $1;
            driver.pop_repContainer($1);
            if ($1->mRepType == 0) {
                delete $1;
                $$ = nullptr;
            }
        }
        |
        transHeader one_or_more_elements {
            $$ = $1;
            driver.pop_repContainer($1);
            if ($1->mRepType == 0) {
                delete $1;
                $$ = nullptr;
            }
        }
        |
        switchHeader '{' caseBody '}'
        {
            $$ = $1;
            $1->unify();
            driver.switchStack.pop();
        }
        |
        element_v2clue {
            error(@1, "Illegal mixture of old and new elements");
            $$ = nullptr;
        }
        ;

element_v2clue:
        USER_RATIONAL '*' { delete $1; }
        | USER_STRING '{' { delete $1; }
        | USER_PATHOP '{' { delete $1; }
        ;

pathOp_v2:
        pathOp_simple_v2 { $$ = $1; }
        |
        loopHeader_v2 one_or_more_pathOp_v2 { 
            $$ = $1;
            driver.pop_repContainer($1);
            if ($1->mRepType == 0) {
                delete $1;
                $$ = nullptr;
            }
        }
        | pathOp_v3clues {
            if (driver.lexer->maybeVersion == token::CFDG2) {
                error(@1, "Illegal mixture of old and new elements");
            } else {
                driver.lexer->maybeVersion = token::CFDG3;
            }
            $$ = nullptr;
            YYABORT;
        }
        ;

pathOp_v3clues:
        USER_PATHOP '(' { delete $1; }
        | USER_STRING '(' { delete $1; }
        | PATH
        | LOOP
        | USER_STRING BECOMES { delete $1; }
        | MODTYPE BECOMES
        | IF
        | MODTYPE
        | SWITCH
        ;

element_loop:
        loopHeader modification one_or_more_elements {
            // parse loop mod and loop body with loop index in scope
            $1->mLoopModHolder.reset($2); $2 = nullptr;
            $$ = $1;
            // loopmod gets deleted
        }
        ;

buncha_replacements_v2: 
        buncha_replacements_v2 replacement_v2 {
            driver.push_rep($2);
        }
        |
        ;

one_or_more_replacements_v2:
        '{' buncha_replacements_v2 '}' { }
        |
        replacement_simple_v2 {
            driver.push_rep($1);
        }
        ;

replacement_simple_v2:
        shapeName modification_v2 {
            str_ptr name($1); $1 = nullptr;
            mod_ptr mod($2); $2 = nullptr;
            ruleSpec_ptr r(driver.MakeRuleSpec(*name, nullptr, @1));
            $$ = new ASTreplacement(std::move(*r), std::move(mod), @$);
        }
        ;

replacement_v2:
        replacement_simple_v2 { $$ = $1; }
        |
        loopHeader_v2 one_or_more_replacements_v2 {
            $$ = $1;
            driver.pop_repContainer($1);
            if ($1->mRepType == 0) {
                delete $1;
                $$ = nullptr;
            }
        }
        ;

loopHeader_v2:
        USER_RATIONAL '*' { ++driver.mLocalStackDepth; } modification_v2 {
            str_ptr cstr($1); $1 = nullptr;
            exp_ptr count(new ASTreal(*cstr, @1));
            mod_ptr mod($4); $4 = nullptr;
            static const std::string dummyvar("~~inaccessiblevar~~");
            --driver.mLocalStackDepth;
            driver.lexer->maybeVersion = token::CFDG2;
            loop_ptr loop(new ASTloop(driver.StringToShape(dummyvar, @2, false), 
                                      dummyvar, @2, std::move(count), @$, std::move(mod)));
            driver.push_repContainer(loop->mLoopBody);
            $$ = loop.release();
        }
        ;

loopHeader:
        LOOP USER_STRING BECOMES exp2 {
            str_ptr var($2); $2 = nullptr;
            exp_ptr index($4); $4 = nullptr;
            int nameIndex = driver.StringToShape(*var, @2, false);
            loop_ptr loop(new ASTloop(nameIndex, *var, @2, std::move(index), @4, nullptr));
            driver.push_repContainer(loop->mLoopBody);
            $$ = loop.release();
        }
        |
        LOOP MODTYPE BECOMES exp2 {
            exp_ptr index($4); $4 = nullptr;
            static const std::string dummyvar("~~inaccessiblevar~~");
            loop_ptr loop(new ASTloop(driver.StringToShape(dummyvar, @1, false), 
                                      dummyvar, @2, std::move(index), @4, nullptr));
            driver.push_repContainer(loop->mLoopBody);
            $$ = loop.release();
            error(@2, "Reserved keyword: adjustment");
        }
        |
        LOOP exp2 {
            exp_ptr count($2); $2 = nullptr;
            static const std::string dummyvar("~~inaccessiblevar~~");
            loop_ptr loop(new ASTloop(driver.StringToShape(dummyvar, @1, false), 
                                      dummyvar, @1, std::move(count), @2, nullptr));
            driver.push_repContainer(loop->mLoopBody);
            $$ = loop.release();
        }
        ;

ifHeader:
        IF '(' exp2 ')' {
            exp_ptr cond($3); $3 = nullptr;
            if_ptr ifHeader(new ASTif(std::move(cond), @3));
            driver.push_repContainer(ifHeader->mThenBody);
            $$ = ifHeader.release();
        }
        ;

ifElseHeader:
        ifHeader one_or_more_elements ELSE {
            driver.pop_repContainer($1);
            driver.push_repContainer($1->mElseBody);
            $$ = $1;
        }
        ;

transHeader:
        MODTYPE exp2 {
            exp_ptr mods($2); $2 = nullptr;
            if ($1 != ASTmodTerm::transform)
                error(@1, "Syntax error");
            ASTtransform* trans = new ASTtransform(@$, std::move(mods));
            driver.push_repContainer(trans->mBody);
            $$ = trans;
        }
        | CLONE exp2 {
            exp_ptr mods($2); $2 = nullptr;
            ASTtransform* trans = new ASTtransform(@$, std::move(mods));
            trans->mClone = true;
            driver.push_repContainer(trans->mBody);
            $$ = trans;
        }
        ;

switchHeader:
        SWITCH '(' exp2 ')' {
            exp_ptr caseVal($3); $3 = nullptr;
            switch_ptr switchHeader(new ASTswitch(std::move(caseVal), @3));
            driver.switchStack.push(switchHeader.get());
            $$ = switchHeader.release();
        }
        ;

caseHeader:
        CASE exp2 ':' {
            exp_ptr valExp($2); $2 = nullptr;
            
            double val = 0.0;
            try {
                if (valExp->evaluate(&val, 1) != 1) {
                    driver.error(@2, "Case expression is not a single, numeric expression");
                } else {
                    int intval = static_cast<int>(floor(val));
                    ASTswitch::switchMap& caseMap = driver.switchStack.top()->mCaseStatements;
                    
                    if (caseMap.count(intval)) {
                        driver.error(@2, "Case value already in use");
                        driver.push_repContainer(*(caseMap[intval]));
                    } else {
                        cont_ptr caseBody(new ASTrepContainer());
                        driver.push_repContainer(*(caseBody.get()));
                        std::pair<int, cont_ptr> p(intval, std::move(caseBody));
                        caseMap.insert(std::move(p));
                    }
                }
            }
            catch (DeferUntilRuntime&) {
                driver.error(@2, "Case expression is not constant");
            }
            $$ = 0;
        }
        |
        ELSE ':' {
            if (!driver.switchStack.top()->mElseBody.mBody.empty()) {
                driver.error(@$, "There can only be one 'else:' clause");
            } else {
                driver.push_repContainer(driver.switchStack.top()->mElseBody);
            }
            $$ = 0;
        }
        ;

modification_v2:
        '{' buncha_adjustments '}' {
            mod_ptr mod($2); $2 = nullptr;
            $$ = driver.MakeModification(std::move(mod), @$, true);
        }
        |
        '[' buncha_adjustments ']' {
            mod_ptr mod($2); $2 = nullptr;
            $$ = driver.MakeModification(std::move(mod), @$, false);
        }
        ;

modification:
        '[' buncha_adjustments ']' {
            mod_ptr mod($2); $2 = nullptr;
            $$ = driver.MakeModification(std::move(mod), @$, true);
        }
        |
        '[' '[' buncha_adjustments ']' ']' {
            mod_ptr mod($3); $3 = nullptr;
            $$ = driver.MakeModification(std::move(mod), @$, false);
        }
        ;
        
buncha_adjustments:
        buncha_adjustments adjustment {
            term_ptr mod($2); $2 = nullptr;
            driver.MakeModTerm($1->modExp, std::move(mod));
            $$ = $1;
        }
        | {
            static const yy::location def;
            ASTmodification* m = new ASTmodification(def);
            m->flags = 0;
            $$ = m;
        }
        ;

adjustment:
        MODTYPE explist {
            exp_ptr mod($2); $2 = nullptr;
            $$ = new ASTmodTerm(static_cast<ASTmodTerm::modTypeEnum>($1), mod.release(), @$);
        }
        |
        MODTYPE exp '|' {
            exp_ptr mod($2); $2 = nullptr;
            if ($1 < ASTmodTerm::hue || $1 > ASTmodTerm::alpha) {
                error(@$, "The target operator can only be applied to color adjustments");
                $$ = nullptr;
            } else {
                $$ = new ASTmodTerm(static_cast<ASTmodTerm::modTypeEnum>($1 + 4), mod.release(), @$);
            }
        }
        |
        PARAM USER_STRING {
            str_ptr p($2); $2 = nullptr;
            $$ = new ASTmodTerm(ASTmodTerm::param, *p, @$);
        }
        |
        PARAM USER_QSTRING {
            str_ptr p($2); $2 = nullptr;
            $$ = new ASTmodTerm(ASTmodTerm::param, *p, @$);
        }
        ;
        
letHeader:
        LET {
            ASTrepContainer* tempHolder = new ASTrepContainer();
            driver.push_repContainer(*tempHolder);
            $$ = tempHolder;
        }
        ;
        
letBody:
        '(' letVariables ';' exp2 ')' {
            $$ = $4;
        }
        ;
        
letVariables:
        letVariables ';' letVariable
        |
        letVariable
        ;
        
letVariable:
        definition {
            driver.push_rep($1);
        }
        ;
        
explist:
        explist exp {
            $$ = ASTexpression::Append($1, $2);
        }
        | 
        exp { 
            $$ = $1; 
        }
        ;


arglist:
        arglist ',' exp3 {
            $$ = $1->append(new ASTparen($3));
        }
        |
        exp3 {
            $$ = new ASTcons(new ASTparen($1), nullptr);
        }
        ;
        
exp:
        USER_RATIONAL       { $$ = new ASTreal(*$1, @$); delete $1; }
        |
        CF_INFINITY         { $$ = new ASTreal(Renderer::Infinity, @$); }
        |
        '(' exp2 ')'        { $$ = new ASTparen($2); }
        | 
        expfunc             { $$ = $1; }
        |
        '-' exp             { $$ = new ASToperator('N', $2, nullptr);; }
        |
        '+' exp             { $$ = new ASToperator('P', $2, nullptr);; }
        |
        exp RANGEOP exp {
            exp_ptr pair($1->append($3)); $1 = nullptr; $3 = nullptr;
            $$ = new ASTfunction("rand", std::move(pair), driver.mSeed, @1, @$);
        }
        |
        exp PLUSMINUSOP exp {
            exp_ptr pair($1->append($3)); $1 = nullptr; $3 = nullptr;
            $$ = new ASTfunction("rand+/-", std::move(pair), driver.mSeed, @1, @$);
        }
        ;

exp2: 
        USER_RATIONAL        { $$ = new ASTreal(*$1, @$); delete $1; $1 = nullptr; }
        |
        CF_INFINITY          { $$ = new ASTreal(Renderer::Infinity, @$); }
        |
        exp2func             { $$ = $1; }
        |
        exp2 RANGEOP exp2 {
            exp_ptr pair($1->append($3)); $1 = nullptr; $3 = nullptr;
            $$ = new ASTfunction("rand", std::move(pair), driver.mSeed, @1, @$);
        }
        |
        exp2 PLUSMINUSOP exp2 {
            exp_ptr pair($1->append($3)); $1 = nullptr; $3 = nullptr;
            $$ = new ASTfunction("rand+/-", std::move(pair), driver.mSeed, @1, @$);
        }
        | 
        exp2 ',' exp2        { $$ = $1->append($3);   }
        | 
        exp2 '+' exp2        { $$ = new ASToperator('+', $1, $3); }
        | 
        exp2 '-' exp2        { $$ = new ASToperator('-', $1, $3); }
        | 
        exp2 '_' exp2        { $$ = new ASToperator('_', $1, $3); }
        | 
        exp2 '*' exp2        { $$ = new ASToperator('*', $1, $3); }
        | 
        exp2 '/' exp2        { $$ = new ASToperator('/', $1, $3); }
        | 
        '-' exp2  %prec NEG  { $$ = new ASToperator('N', $2, nullptr); }
        | 
        '+' exp2  %prec POS  { $$ = new ASToperator('P', $2, nullptr); }
        | 
        NOT exp2             { $$ = new ASToperator('!', $2, nullptr); }
        | 
        exp2 '^' exp2        { $$ = new ASToperator('^', $1, $3); }
        | 
        exp2 LT exp2         { $$ = new ASToperator('<', $1, $3); }
        | 
        exp2 LE exp2         { $$ = new ASToperator('L', $1, $3); }
        | 
        exp2 GT exp2         { $$ = new ASToperator('>', $1, $3); }
        | 
        exp2 GE exp2         { $$ = new ASToperator('G', $1, $3); }
        | 
        exp2 EQ exp2         { $$ = new ASToperator('=', $1, $3); }
        | 
        exp2 NEQ exp2        { $$ = new ASToperator('n', $1, $3); }
        | 
        exp2 AND exp2        { $$ = new ASToperator('&', $1, $3); }
        | 
        exp2 OR exp2         { $$ = new ASToperator('|', $1, $3); }
        | 
        exp2 XOR exp2        { $$ = new ASToperator('X', $1, $3); }
        | 
        '(' exp2 ')'         { $$ = new ASTparen($2); }
        | 
        modification         { $$ = $1; }
        ;

exp3:
        USER_RATIONAL        { $$ = new ASTreal(*$1, @$); delete $1; }
        |
        CF_INFINITY          { $$ = new ASTreal(Renderer::Infinity, @$); }
        |
        exp2func             { $$ = $1; }
        |
        exp3 RANGEOP exp3 {
            exp_ptr pair($1->append($3)); $1 = nullptr; $3 = nullptr;
            $$ = new ASTfunction("rand", std::move(pair), driver.mSeed, @1, @$);
        }
        |
        exp3 PLUSMINUSOP exp3 {
            exp_ptr pair($1->append($3)); $1 = nullptr; $3 = nullptr;
            $$ = new ASTfunction("rand+/-", std::move(pair), driver.mSeed, @1, @$);
        }
        | 
        exp3 '+' exp3        { $$ = new ASToperator('+', $1, $3); }
        | 
        exp3 '-' exp3        { $$ = new ASToperator('-', $1, $3); }
        | 
        exp3 '_' exp3        { $$ = new ASToperator('_', $1, $3); }
        | 
        exp3 '*' exp3        { $$ = new ASToperator('*', $1, $3); }
        | 
        exp3 '/' exp3        { $$ = new ASToperator('/', $1, $3); }
        | 
        '-' exp3  %prec NEG  { $$ = new ASToperator('N', $2, nullptr); }
        | 
        '+' exp3  %prec POS  { $$ = new ASToperator('P', $2, nullptr); }
        | 
        NOT exp3             { $$ = new ASToperator('!', $2, nullptr); }
        | 
        exp3 '^' exp3        { $$ = new ASToperator('^', $1, $3); }
        | 
        exp3 LT exp3         { $$ = new ASToperator('<', $1, $3); }
        | 
        exp3 LE exp3         { $$ = new ASToperator('L', $1, $3); }
        | 
        exp3 GT exp3         { $$ = new ASToperator('>', $1, $3); }
        | 
        exp3 GE exp3         { $$ = new ASToperator('G', $1, $3); }
        | 
        exp3 EQ exp3         { $$ = new ASToperator('=', $1, $3); }
        | 
        exp3 NEQ exp3        { $$ = new ASToperator('n', $1, $3); }
        | 
        exp3 AND exp3        { $$ = new ASToperator('&', $1, $3); }
        | 
        exp3 OR exp3         { $$ = new ASToperator('|', $1, $3); }
        | 
        exp3 XOR exp3        { $$ = new ASToperator('X', $1, $3); }
        | 
        '(' exp2 ')'         { $$ = new ASTparen($2); }
        | 
        modification         { $$ = $1; }
        ;

expfunc:
        USER_STRING '(' ')'   { 
            str_ptr func($1); $1 = nullptr;
            $$ = driver.MakeFunction(std::move(func), nullptr, @1, @2 + @3, false);
        }
        | 
        USER_STRING '(' arglist ')'   { 
            str_ptr func($1); $1 = nullptr;
            exp_ptr args($3); $3 = nullptr;
            $$ = driver.MakeFunction(std::move(func), std::move(args), @1, @3, true);
        }
        | 
        USER_ARRAYNAME '[' exp2 ']'   { 
            str_ptr func($1); $1 = nullptr;
            exp_ptr args($3); $3 = nullptr;
            $$ = driver.MakeArray(std::move(func), std::move(args), @1, @3);
        }
        |
        IF '(' exp2 ')'   { 
            str_ptr func(new std::string("if"));
            exp_ptr args($3); $3 = nullptr;
            $$ = driver.MakeFunction(std::move(func), std::move(args), @1, @3, false);
        }
        |
        letHeader letBody {
            driver.pop_repContainer(nullptr);
            cont_ptr vars($1); $1 = nullptr;
            exp_ptr exp($2); $2 = nullptr;
            $$ = driver.MakeLet(@1, std::move(vars), std::move(exp));
        }
        |
        USER_STRING { 
            str_ptr var($1); $1 = nullptr;
            $$ = driver.MakeVariable(*var, @1);
        }
        ;

exp2func:
        USER_STRING '(' ')'   { 
            str_ptr func($1); $1 = nullptr;
            $$ = driver.MakeFunction(std::move(func), nullptr, @1, @2 + @3, false);
        }
        | 
        USER_STRING '(' arglist ')'   { 
            str_ptr func($1); $1 = nullptr;
            exp_ptr args($3); $3 = nullptr;
            $$ = driver.MakeFunction(std::move(func), std::move(args), @1, @3, false);
        }
        | 
        USER_ARRAYNAME '[' exp2 ']'   { 
            str_ptr func($1); $1 = nullptr;
            exp_ptr args($3); $3 = nullptr;
            $$ = driver.MakeArray(std::move(func), std::move(args), @1, @3);
        }
        | 
        IF '(' exp2 ')'   { 
            str_ptr func(new std::string("if"));
            exp_ptr args($3); $3 = nullptr;
            $$ = driver.MakeFunction(std::move(func), std::move(args), @1, @3, false);
        }
        |
        USER_STRING '(' BECOMES ')'   { 
            str_ptr func($1); $1 = nullptr;
            exp_ptr args(new ASTexpression(@$, false, false, AST::ReuseType));
            $$ = driver.MakeFunction(std::move(func), std::move(args), @1, @3, false);
        }
        |
        letHeader letBody {
            driver.pop_repContainer(nullptr);
            cont_ptr vars($1); $1 = nullptr;
            exp_ptr exp($2); $2 = nullptr;
            $$ = driver.MakeLet(@1, std::move(vars), std::move(exp));
        }
        |
        USER_STRING { 
            str_ptr var($1); $1 = nullptr;
            $$ = driver.MakeVariable(*var, @1);
        }
        ;

shapeName:
        USER_STRING { $$ = $1; }
        |
        USER_ARRAYNAME { $$ = $1; }
        ;
        
%%

void yy::CfdgParser::error(const CfdgParser::location_type& l, const std::string& m)
{
    driver.error(l, m);
}
